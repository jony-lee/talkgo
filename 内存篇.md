# 概念

内存地址映射：将虚拟内存地址的内容映射到物理内存地址上，使用的是MMU（内存管理单元），其中映射页表是存储在MMU单元中的，它是一个独立的硬件单元。

内存映射最小单位为内存页表，其大小为4kb

但这造成一个问题，就是页表项特别多，32位机系统就需要100w（4G/4K）项才能够映射整个地址空间。

解决办法两个 **多级页表**   **大页**

请简单阐述多级页表和大页对linux操作系统的积极作用。

内存分配是一个懒分配的过程，当通过malloc分配内存时并不会立即分配一块物理内存，而是在首次访问该内存时，通过缺页异常陷入内核中进行分配

OOM:内核保护机制，利用oom_score为每个进程的内存使用进行打分，消耗内存越大oom_score越大，占用cpu越oom_score越小。当oom_score越大时，进程越容易被oom杀死。可通过/proc文件系统手动调整某一进程的oom_adj参数。


```
调整相关参数的代码
echo -16 > /proc/$(pidof sshd)/oom_adj
```

系统回收内存的三种机制
1. 回收缓存，基于LRU算法
2. 内存磁盘空间交换，将不常访问的内存写入到磁盘
3. 杀死进程，oom触发时将对应进程杀死


cache 和 buffer 的区别

buffer缓存磁盘内容，约20MB，内核首先将内容存储在buffer中，然后统一写入磁盘，这样能够减少刷写磁盘的次数，从而提高效率

cache是从磁盘读取文件的页缓存，当频繁访问文件的时候就会经常用到这个cache。

利用系统缓存优化程序的运行效率

如何提高缓存命中，将经常访问的数据提前读入到内存当中，从而降低每次从硬盘中读入数据的时间。

cachestat 提供了整个操作系统缓存的读写命中情况。

cachetop 提供了每个进程的缓存命中情况。

pcstat 查看文件在内存中的缓存大小以及缓存比例。
 
内存泄露：分配了内存没有进行正确的回收导致该部分占用的内存越来越大直至触发oom被杀。

导致内存泄露问题复杂的因素：
1. malloc() 和 free() 通常并不是成对出现，而是需要你，在每个异常处理路径和成功路径上都释放内存 。
2. 在多线程程序中，一个线程中分配的内存，可能会在另一个线程中访问和释放。
3. 更复杂的是，在第三方的库函数中，隐式分配的内存可能需要应用程序显式释放。

系统swap变高的原因

如何衡量内存是不是紧张？



# 实战
1. 利用dd，dd 作为一个磁盘和文件的拷贝工具，经常被拿来测试磁盘或者文件系统的读写性能。
```
# 生成一个512MB的临时文件
$ dd if=/dev/sda1 of=file bs=1M count=512
# 清理缓存
$ echo 3 > /proc/sys/vm/drop_caches
```



# 总结
